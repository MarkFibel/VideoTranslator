# VideoTranslator

Общее описание проекта 

## Описание Нейронки

...

## Описание Фронта

...

## Бекенд архитектура

![Backend Architecture](./docs/backend_architecture.png)

Бэкенд состоит из двух основных частей: API сервер и обработчики сервисов.
API сервер отвечает за обработку HTTP запросов и маршрутизацию.
Обработчики сервисов реализуют бизнес-логику и взаимодействие с внешними системами.

### Технологический стек

**Основные технологии:**
- **FastAPI** - современный, высокопроизводительный веб-фреймворк для построения API.
- **Python 3.12+** - актуальная версия Python.
- **Asyncio** - для асинхронной обработки I/O.
- **aio-pika** - асинхронный клиент для работы с RabbitMQ.
- **jsonrpcserver** - реализация JSON-RPC протокола для межсервисного взаимодействия.

**Дополнительные библиотеки:**
- **Pydantic v2** - валидация данных и управление настройками.
- **Uvicorn** - ASGI сервер для запуска приложения.
- **python-multipart** - обработка загрузки файлов.
- **aiofiles** - асинхронная работа с файловой системой.

### Структура проекта

```
src/
├── app.py                    # Главный файл, инициализация FastAPI
├── routes.py                 # Объединение всех роутеров
├── worker.py                 # Точка входа для запуска RabbitMQ воркера
├── config/                   # Конфигурация приложения
│   ├── app_config.py         # Основные настройки (размер файлов, порты)
│   ├── logging_config.py     # Настройка системы логирования
│   ├── rabbitmq_config.py    # Настройки RabbitMQ
│   └── services/             # Конфигурации для отдельных сервисов
├── routers/                  # HTTP роутеры (endpoints)
│   ├── file_router.py        # Endpoints для работы с файлами
│   └── frontend_router.py    # Endpoints для фронтенда
├── services/                 # Бизнес-логика и сервисы
│   └── base_service.py       # Базовый класс для всех сервисов
├── schemas/                  # Pydantic модели для валидации
│   ├── base_schema.py        # Базовые схемы
│   └── response_schema.py    # Схемы ответов API
├── transport/                # Компоненты для межсервисного взаимодействия
│   ├── json-rpc/             # Реализация JSON-RPC
│   │   ├── dispatcher.py     # Основной диспетчер
│   │   └── service_loader.py # Логика автообнаружения сервисов
│   └── rabbitmq/             # Компоненты для работы с RabbitMQ
│       ├── connection.py     # Менеджер соединений
│       ├── consumer.py       # Логика консьюмера (слушателя)
│       ├── producer.py       # Логика продюсера (отправителя)
│       └── constants.py      # Имена очередей и обменников
└── utils/
    └── string_utils.py       # Утилиты для работы со строками
```

### API сервер

API сервер реализован с использованием FastAPI и является точкой входа для всех HTTP запросов. Основные компоненты:

#### Инициализация приложения (`app.py`)

Приложение инициализируется через фабричную функцию `get_application()`, которая:
- Настраивает FastAPI с указанием названия проекта, версии и режима отладки
- Подключает все роутеры через централизованную функцию `get_apps_router()`
- Монтирует статические файлы из директории `public/` для обслуживания фронтенда
- Инициализирует систему логирования с настройками из конфигурации

```python
app = get_application()
# Запуск: uvicorn src.app:app --host 0.0.0.0 --port 8000
```

#### Система маршрутизации

Маршрутизация организована модульно через отдельные роутеры:

**Frontend Router** (`frontend_router.py`):
- Обслуживает главную страницу приложения
- Автоматически выдает HTML контент с поддержкой CSRF защиты
- Endpoint: `GET /` - возвращает `index.html`

**File Router** (`file_router.py`):
- Обрабатывает загрузку файлов от пользователей
- Endpoint: `POST /files/upload` - принимает multipart/form-data с файлом
- Валидирует размер файла (макс. 10MB по умолчанию)
- Возвращает метаданные загруженного файла (имя, тип, размер, время загрузки)
- В будущем будет отправлять задачи в очередь RabbitMQ для фоновой обработки

#### Конфигурация (`config/`)

**Настройки приложения** (`app_config.py`):
Использует Pydantic Settings для управления конфигурацией с поддержкой `.env` файлов:
- `PROJECT_NAME` - название проекта
- `VERSION` - версия API
- `DEBUG` - режим отладки
- `LOG_LEVEL` - уровень логирования (DEBUG, INFO, WARNING, ERROR)
- `LOG_DIR` - директория для файлов логов
- `MAX_FILE_SIZE` - максимальный размер загружаемого файла (10MB)

**Система логирования** (`logging_config.py`):
Комплексная система логирования с несколькими обработчиками:
- **Console Handler** - вывод в консоль для разработки
- **File Info Handler** - запись общих логов в `var/log/app.log` с ротацией (5 файлов по 10MB)
- **File Error Handler** - отдельный файл `var/log/error.log` только для ошибок
- Структурированный формат логов с временными метками, именем модуля и номером строки
- Специальная конфигурация для логгеров uvicorn и fastapi

#### Схемы данных (`schemas/`)

Используются Pydantic модели для валидации входящих и исходящих данных:

**BaseResponse** - базовая схема для всех ответов API:
```python
{
    "status": "success" | "error",
    "message": "Описание результата",
    "error": "Детали ошибки (если есть)"
}
```

**FileUploadResponse** - расширенная схема для загрузки файлов:
```python
{
    "status": "success",
    "message": "File uploaded successfully",
    "data": {
        "filename": "video.mp4",
        "content_type": "video/mp4",
        "size": 1048576,
        "upload_time": "2025-10-18T12:00:00"
    }
}
```

#### Обработка ошибок

Реализована централизованная обработка исключений:
- HTTP ошибки выбрасываются через `HTTPException` с соответствующими статус-кодами
- Все неожиданные ошибки логируются с полным стек-трейсом
- Клиент получает структурированный JSON ответ даже при ошибках
- Используются стандартные HTTP статус-коды (400, 404, 500 и т.д.)

### Обработчики сервисов (Workers)

Обработчики сервисов (воркеры) — это независимые асинхронные процессы, которые выполняют основную бизнес-логику. Они полностью отделены от API-сервера и взаимодействуют с ним через брокер сообщений RabbitMQ.

#### Архитектура сервисов и JSON-RPC

В основе архитектуры лежит механизм **JSON-RPC**, который позволяет стандартизировать вызовы методов сервисов.

- **`BaseService`**: Все сервисы наследуются от этого базового класса. Он отвечает за автоматическую загрузку конфигурации из `src/config/services/`. Если конфигурационный файл для сервиса отсутствует, он создается автоматически.
- **Автообнаружение сервисов**: `ServiceLoader` (`src/transport/json-rpc/service_loader.py`) при старте сканирует каталог `src/services/`, находит всех наследников `BaseService` и регистрирует их методы.
- **`JSONRPCDispatcher`**: Ядро, построенное на `jsonrpcserver`, которое принимает JSON-RPC запросы, находит нужный метод и выполняет его. Имя метода в RPC формируется из имени сервиса (например, `VideoProcessingService` -> `video_processing.execute`).
- **Контракт сервиса**: Каждый сервис должен реализовать метод `execute(data: dict)`, который и будет вызываться удаленно.

#### Взаимодействие через RabbitMQ

API-сервер и воркеры общаются через RabbitMQ, что обеспечивает асинхронность и масштабируемость.

- **`worker.py`**: Точка входа для запуска воркера как отдельного процесса (`python -m src.worker`). Воркер слушает очередь RabbitMQ.
- **`RPCConsumer`**: Компонент воркера, который принимает сообщения из очереди. При получении сообщения он передает его в `JSONRPCDispatcher` для выполнения соответствующего метода сервиса.
- **`RPCProducer`**: Компонент на стороне API-сервера, который отправляет задачи в очередь. Он использует паттерн **Direct Reply-to** для получения ответа от воркера без создания временных очередей.
- **`ConnectionManager`**: Управляет подключением к RabbitMQ и обеспечивает переподключение в случае сбоев.

#### Последовательность работы

1.  **API-сервер** (например, при загрузке файла) использует `RPCProducer` для отправки задачи в очередь RabbitMQ. Задача содержит имя метода (например, `video_processing.execute`) и параметры.
2.  **Воркер** (`RPCConsumer`) получает задачу из очереди.
3.  Содержимое задачи передается в **`JSONRPCDispatcher`**, который вызывает нужный метод у соответствующего сервиса.
4.  Сервис выполняет бизнес-логику (например, обработку видео).
5.  Результат выполнения возвращается API-серверу через `reply_to` очередь.
6.  API-сервер получает результат и может, при необходимости, уведомить клиента.

Эта архитектура позволяет горизонтально масштабировать воркеры: для увеличения производительности достаточно запустить больше экземпляров `worker.py`.



## Установка и запуск

...